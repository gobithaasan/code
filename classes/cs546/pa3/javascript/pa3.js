// Generated by CoffeeScript 1.9.1
(function() {
  var Line, R_INC, SVG_SIZE, SVG_STROKE, callback, clear, createMeshLines, createSVGLine, err, generalizedTransformation, getVertexRanges, isometricProjection, load, loadObject, main, orthoProj, parseFace, parseVertex, rescaleVertices, rotate, union;

  SVG_SIZE = 400;

  SVG_STROKE = 0.5;

  R_INC = Math.PI / 8;

  loadObject = function(url, store, cb, cbErr) {
    var req;
    req = new XMLHttpRequest();
    req.open('GET', url, true);
    req.onreadystatechange = function() {
      if (req.readyState === 4) {
        if (req.status === 200) {
          return cb(store, req.responseText);
        } else {
          return cbErr(url);
        }
      }
    };
    return req.send(null);
  };

  parseVertex = function(vertexString) {
    var ref, split, x, y, z;
    split = vertexString.split(' ');
    ref = split.slice(1, 4), x = ref[0], y = ref[1], z = ref[2];
    return {
      x: parseFloat(x),
      y: parseFloat(y),
      z: parseFloat(z)
    };
  };

  parseFace = function(faceString) {
    var i, k, len1, ref, results, split;
    split = faceString.split(' ');
    ref = split.slice(1);
    results = [];
    for (k = 0, len1 = ref.length; k < len1; k++) {
      i = ref[k];
      results.push(parseInt(i) - 1);
    }
    return results;
  };

  Array.prototype.max = function() {
    return Math.max.apply(null, this);
  };

  Array.prototype.min = function() {
    return Math.min.apply(null, this);
  };

  getVertexRanges = function(vertices) {
    var v, xs, ys, zs;
    xs = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = vertices.length; k < len1; k++) {
        v = vertices[k];
        results.push(v.x);
      }
      return results;
    })();
    ys = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = vertices.length; k < len1; k++) {
        v = vertices[k];
        results.push(v.y);
      }
      return results;
    })();
    zs = (function() {
      var k, len1, results;
      results = [];
      for (k = 0, len1 = vertices.length; k < len1; k++) {
        v = vertices[k];
        results.push(v.z);
      }
      return results;
    })();
    return {
      x1: xs.min(),
      x2: xs.max(),
      y1: ys.min(),
      y2: ys.max(),
      z1: zs.min(),
      z2: zs.max()
    };
  };

  rescaleVertices = function(vertices, size) {
    var k, len1, r, results, rm, rx, ry, rz, v;
    r = getVertexRanges(vertices);
    rx = r.x2 - r.x1;
    ry = r.y2 - r.y1;
    rz = r.z2 - r.z1;
    rm = Math.max(rx, ry, rz);
    results = [];
    for (k = 0, len1 = vertices.length; k < len1; k++) {
      v = vertices[k];
      results.push({
        x: .05 * size + .90 * size * (rm - rx - 2 * r.x1 + 2 * v.x) / (2 * rm),
        y: .05 * size + .90 * size * (rm - ry - 2 * r.y1 + 2 * v.y) / (2 * rm),
        z: .95 * size - .90 * size * (rm - rz - 2 * r.z1 + 2 * v.z) / (2 * rm)
      });
    }
    return results;
  };

  orthoProj = function(vertices) {
    var v;
    return {
      xy: (function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = vertices.length; k < len1; k++) {
          v = vertices[k];
          results.push({
            x: v.x,
            y: v.y
          });
        }
        return results;
      })(),
      xz: (function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = vertices.length; k < len1; k++) {
          v = vertices[k];
          results.push({
            x: v.x,
            y: v.z
          });
        }
        return results;
      })(),
      yz: (function() {
        var k, len1, results;
        results = [];
        for (k = 0, len1 = vertices.length; k < len1; k++) {
          v = vertices[k];
          results.push({
            x: v.y,
            y: v.z
          });
        }
        return results;
      })()
    };
  };

  union = function(a) {
    var i, item, j, k, len, out, ref, ref1, seen;
    seen = Object.create(null);
    out = [];
    len = a.length;
    j = 0;
    for (i = k = 0, ref = len; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      item = a[i];
      if (seen[item] !== 1) {
        ref1 = [1, item], seen[item] = ref1[0], out[j++] = ref1[1];
      }
    }
    return out;
  };

  Line = (function() {
    Line.prototype.p1 = 0;

    Line.prototype.p2 = 0;

    function Line(p1, p2) {
      if (p1 == null) {
        p1 = this.p1;
      }
      if (p2 == null) {
        p2 = this.p2;
      }
      this.p1 = p1;
      this.p2 = p2;
    }

    Line.prototype.toString = function() {
      return "(" + (this.p1.toString()) + ", " + (this.p2.toString()) + ")";
    };

    return Line;

  })();

  createMeshLines = function(faces) {
    var face, i, k, l, len, len1, lines, ref, v1, v2;
    lines = [];
    for (k = 0, len1 = faces.length; k < len1; k++) {
      face = faces[k];
      len = face.length;
      for (i = l = 0, ref = len; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
        v1 = Math.min(face[i], face[(i + 1) % len]);
        v2 = Math.max(face[i], face[(i + 1) % len]);
        lines.push(new Line(v1, v2));
      }
    }
    return union(lines);
  };

  createSVGLine = function(p1, p2, stroke) {
    var line;
    line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', p1.x);
    line.setAttribute('y1', p1.y);
    line.setAttribute('x2', p2.x);
    line.setAttribute('y2', p2.y);
    line.setAttribute('stroke-width', stroke);
    line.setAttribute('stroke', 'black');
    return line;
  };

  callback = function(obj, txt) {
    var containerIP, containerXY, containerXZ, containerYZ, createLabel, i, ip1, ip2, ips1, ips2, k, l, len1, len2, line, lineIP, lineXY, lineXZ, lineYZ, lines, op, ref, ref1, svg, svgIP, svgXY, svgXZ, svgYZ;
    lines = txt.split('\n');
    for (k = 0, len1 = lines.length; k < len1; k++) {
      line = lines[k];
      if (line[0] === 'v') {
        obj.vertices.push(parseVertex(line));
      }
      if (line[0] === 'f') {
        obj.faces.push(parseFace(line));
      }
    }
    obj.vertices = rescaleVertices(obj.vertices, SVG_SIZE);
    op = orthoProj(obj.vertices);
    ref = (function() {
      var l, results;
      results = [];
      for (i = l = 1; l <= 4; i = ++l) {
        svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', SVG_SIZE);
        svg.setAttribute('height', SVG_SIZE);
        svg.setAttribute('style', "border: 1px solid black;");
        results.push(svg);
      }
      return results;
    })(), svgXY = ref[0], svgXZ = ref[1], svgYZ = ref[2], svgIP = ref[3];
    obj.meshLines = createMeshLines(obj.faces);
    ref1 = obj.meshLines;
    for (l = 0, len2 = ref1.length; l < len2; l++) {
      line = ref1[l];
      lineXY = createSVGLine(op.xy[line.p1], op.xy[line.p2], SVG_STROKE);
      lineXZ = createSVGLine(op.xz[line.p1], op.xz[line.p2], SVG_STROKE);
      lineYZ = createSVGLine(op.yz[line.p1], op.yz[line.p2], SVG_STROKE);
      ip1 = isometricProjection(obj.vertices[line.p1]);
      ip2 = isometricProjection(obj.vertices[line.p2]);
      ips1 = {
        x: ip1.x + SVG_SIZE / 2,
        y: ip1.y - SVG_SIZE / 3
      };
      ips2 = {
        x: ip2.x + SVG_SIZE / 2,
        y: ip2.y - SVG_SIZE / 3
      };
      lineIP = createSVGLine(ips1, ips2, SVG_STROKE);
      svgXY.appendChild(lineXY);
      svgXZ.appendChild(lineXZ);
      svgYZ.appendChild(lineYZ);
      svgIP.appendChild(lineIP);
      obj.svgLinesXY.push(lineXY);
      obj.svgLinesXZ.push(lineXZ);
      obj.svgLinesYZ.push(lineYZ);
      obj.svgLinesIP.push(lineIP);
    }
    createLabel = function(text) {
      var label;
      label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', 10);
      label.setAttribute('y', 38);
      label.setAttribute('fill', 'red');
      label.setAttribute('font-size', '28px');
      label.setAttribute('font-family', 'helvetica');
      label.innerHTML = text;
      return label;
    };
    svgXY.appendChild(createLabel('xy'));
    svgXZ.appendChild(createLabel('xz'));
    svgYZ.appendChild(createLabel('yz'));
    svgIP.appendChild(createLabel('isometric'));
    containerXY = document.getElementById('containerXY');
    containerXZ = document.getElementById('containerXZ');
    containerYZ = document.getElementById('containerYZ');
    containerIP = document.getElementById('containerIP');
    clear();
    containerXY.appendChild(svgXY);
    containerXZ.appendChild(svgXZ);
    containerYZ.appendChild(svgYZ);
    return containerIP.appendChild(svgIP);
  };

  rotate = function(object3D, txy, txz, tyz) {
    var ctxy, ctxz, ctyz, i, ip1, ip2, ips1, ips2, k, lineIP, meshLine, p1, p2, ref, rotatedVertices, s2x, s2y, s2z, size, stxy, stxz, styz, v, x, y, z;
    ctxy = Math.cos(txy);
    ctxz = Math.cos(txz);
    ctyz = Math.cos(tyz);
    stxy = Math.sin(txy);
    stxz = Math.sin(txz);
    styz = Math.sin(tyz);
    size = SVG_SIZE;
    rotatedVertices = (function() {
      var k, len1, ref, ref1, results;
      ref = object3D.vertices;
      results = [];
      for (k = 0, len1 = ref.length; k < len1; k++) {
        v = ref[k];
        ref1 = [v.x, v.y, v.z], x = ref1[0], y = ref1[1], z = ref1[2];
        s2x = size - 2 * x;
        s2y = size - 2 * y;
        s2z = size - 2 * z;
        results.push({
          x: (-(ctxy * ctxz * s2x) + size + ctxz * s2y * stxy - s2z * stxz) / 2.0,
          y: (size - ctyz * s2x * stxy + ctxz * s2z * styz + s2y * stxy * stxz * styz - ctxy * (ctyz * s2y + s2x * stxz * styz)) / 2.0,
          z: (-(ctxz * ctyz * s2z) + size + ctyz * (ctxy * s2x - s2y * stxy) * stxz - (ctxy * s2y + s2x * stxy) * styz) / 2.0
        });
      }
      return results;
    })();
    for (i = k = 0, ref = object3D.meshLines.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      meshLine = object3D.meshLines[i];
      p1 = rotatedVertices[meshLine.p1];
      p2 = rotatedVertices[meshLine.p2];
      object3D.svgLinesXY[i].setAttribute('x1', p1.x);
      object3D.svgLinesXY[i].setAttribute('y1', p1.y);
      object3D.svgLinesXY[i].setAttribute('x2', p2.x);
      object3D.svgLinesXY[i].setAttribute('y2', p2.y);
      object3D.svgLinesXZ[i].setAttribute('x1', p1.x);
      object3D.svgLinesXZ[i].setAttribute('y1', p1.z);
      object3D.svgLinesXZ[i].setAttribute('x2', p2.x);
      object3D.svgLinesXZ[i].setAttribute('y2', p2.z);
      object3D.svgLinesYZ[i].setAttribute('x1', p1.y);
      object3D.svgLinesYZ[i].setAttribute('y1', p1.z);
      object3D.svgLinesYZ[i].setAttribute('x2', p2.y);
      object3D.svgLinesYZ[i].setAttribute('y2', p2.z);
      ip1 = isometricProjection(p1);
      ip2 = isometricProjection(p2);
      ips1 = {
        x: ip1.x + SVG_SIZE / 2,
        y: ip1.y - SVG_SIZE / 3
      };
      ips2 = {
        x: ip2.x + SVG_SIZE / 2,
        y: ip2.y - SVG_SIZE / 3
      };
      lineIP = createSVGLine(ips1, ips2, SVG_STROKE);
      object3D.svgLinesIP[i].setAttribute('x1', ips1.x);
      object3D.svgLinesIP[i].setAttribute('y1', ips1.y);
      object3D.svgLinesIP[i].setAttribute('x2', ips2.x);
      object3D.svgLinesIP[i].setAttribute('y2', ips2.y);
    }
    return object3D.vertices = rotatedVertices;
  };

  isometricProjection = function(v) {
    return {
      x: (v.x - v.y) / Math.sqrt(2.0),
      y: (v.x + v.y + 2.0 * v.z) / Math.sqrt(6.0)
    };
  };

  generalizedTransformation = function(scale, translation, shear, rotation, perspective, point) {};

  clear = function() {
    var cc;
    cc = function(cname) {
      var container, results;
      container = document.getElementById(cname);
      results = [];
      while (container.hasChildNodes()) {
        results.push(container.removeChild(container.firstChild));
      }
      return results;
    };
    cc('containerXY');
    cc('containerXZ');
    cc('containerYZ');
    return cc('containerIP');
  };

  err = function(url) {
    return alert("failed to load " + url);
  };

  load = function(object) {
    var object3D;
    object3D = {
      vertices: [],
      faces: [],
      meshLines: [],
      svgLinesXY: [],
      svgLinesXZ: [],
      svgLinesYZ: [],
      svgLinesIP: []
    };
    loadObject("objects/" + object + ".obj", object3D, callback, err);
    return object3D;
  };

  main = function() {
    var object3D;
    SVG_SIZE = Math.min(window.innerWidth - 30, window.innerHeight - 175) / 2;
    document.getElementById('imgTbl').width = 2 * SVG_SIZE;
    object3D = load('SpaceShuttle');
    document.getElementById('selector').addEventListener("change", (function(_this) {
      return function(e) {
        return object3D = load(selector.value);
      };
    })(this));
    document.getElementById('rotateXY+').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, -R_INC, 0, 0);
      };
    })(this));
    document.getElementById('rotateXZ+').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, 0, R_INC, 0);
      };
    })(this));
    document.getElementById('rotateYZ+').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, 0, 0, -R_INC);
      };
    })(this));
    document.getElementById('rotateXY-').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, R_INC, 0, 0);
      };
    })(this));
    document.getElementById('rotateXZ-').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, 0, -R_INC, 0);
      };
    })(this));
    return document.getElementById('rotateYZ-').addEventListener("click", (function(_this) {
      return function(e) {
        return rotate(object3D, 0, 0, R_INC);
      };
    })(this));
  };

  main();

}).call(this);

//# sourceMappingURL=pa3.js.map
